# 🏗️ 智能商品匹配系统 - 技术架构文档

## 📋 技术选型

### 前端技术栈

- **框架**: Next.js 14.x + React 18.x + TypeScript 5.x
- **UI 组件库**: NextUI 2.x (基于 React Aria + Tailwind CSS)
- **状态管理**: Zustand + SWR/TanStack Query
- **路由**: Next.js App Router
- **图表**: Recharts + D3.js
- **文件上传**: react-dropzone + @next/upload
- **表格**: @tanstack/react-table
- **样式**: Tailwind CSS + CSS-in-JS (styled-jsx)
- **构建工具**: Next.js (Turbopack)
- **包管理**: pnpm

### 后端技术栈

- **运行时**: Node.js 18.x LTS
- **框架**: Express.js 4.x + TypeScript
- **数据库**: MongoDB 7.x + Mongoose ODM
- **缓存**: Redis 7.x
- **文件处理**: multer + xlsx + csv-parser
- **认证**: JWT + bcrypt
- **日志**: winston + morgan
- **API 文档**: Swagger/OpenAPI 3.x
- **进程管理**: PM2
- **任务队列**: Bull Queue

### 开发运维

- **进程管理**: PM2 + Nginx
- **代码质量**: ESLint + Prettier + Husky
- **测试**: Jest + React Testing Library
- **CI/CD**: 自动化脚本 + Git Hooks
- **监控**: PM2 监控 + 自定义监控
- **日志管理**: Winston + 日志轮转

---

## 🏛️ 系统架构图

```
┌─────────────────────────────────────────────────────┐
│                    CDN/静态资源                      │
└─────────────────────┬───────────────────────────────┘
                      │
┌─────────────────────▼───────────────────────────────┐
│                  负载均衡器                          │
│                 (Nginx/ALB)                        │
└─────────────────────┬───────────────────────────────┘
                      │
        ┌─────────────┼─────────────┐
        │             │             │
┌───────▼────┐ ┌──────▼────┐ ┌──────▼────┐
│  Web服务1   │ │  Web服务2  │ │  Web服务3  │
│  (Node.js)  │ │ (Node.js) │ │ (Node.js) │
└───────┬────┘ └──────┬────┘ └──────┬────┘
        │             │             │
        └─────────────┼─────────────┘
                      │
        ┌─────────────┼─────────────┐
        │             │             │
┌───────▼────┐ ┌──────▼────┐ ┌──────▼────┐
│Redis缓存   │ │ MongoDB   │ │文件存储   │
│集群        │ │副本集     │ │(Minio)    │
└────────────┘ └───────────┘ └───────────┘
```

---

## 📁 项目结构

### 前端项目结构

```
smart-match-web/
├── public/
│   ├── favicon.ico
│   └── images/
├── src/
│   ├── app/                 # Next.js App Router
│   │   ├── (dashboard)/     # 路由组
│   │   │   ├── dashboard/
│   │   │   ├── products/
│   │   │   ├── matching/
│   │   │   ├── review/
│   │   │   ├── prices/
│   │   │   └── reports/
│   │   ├── auth/
│   │   ├── api/             # API路由
│   │   ├── globals.css
│   │   ├── layout.tsx
│   │   └── page.tsx
│   ├── components/          # 通用组件
│   │   ├── ui/              # 基础UI组件
│   │   ├── Upload/
│   │   ├── DataTable/
│   │   ├── MatchingCard/
│   │   └── Charts/
│   ├── lib/                 # 工具库
│   │   ├── utils.ts
│   │   ├── api.ts
│   │   └── auth.ts
│   ├── hooks/               # 自定义Hooks
│   ├── stores/              # 状态管理
│   │   ├── auth.ts
│   │   ├── matching.ts
│   │   └── products.ts
│   ├── types/               # TypeScript类型定义
│   └── constants/           # 常量定义
├── package.json
├── next.config.js
├── tsconfig.json
├── tailwind.config.ts
└── components.json          # NextUI配置
```

### 后端项目结构

```
smart-match-api/
├── src/
│   ├── controllers/         # 控制器
│   │   ├── auth.controller.ts
│   │   ├── product.controller.ts
│   │   ├── matching.controller.ts
│   │   └── price.controller.ts
│   ├── services/            # 业务逻辑服务
│   │   ├── matching.service.ts
│   │   ├── excel.service.ts
│   │   └── notification.service.ts
│   ├── models/              # 数据模型
│   │   ├── Product.ts
│   │   ├── MatchingTask.ts
│   │   └── User.ts
│   ├── middleware/          # 中间件
│   │   ├── auth.middleware.ts
│   │   ├── validation.middleware.ts
│   │   └── error.middleware.ts
│   ├── routes/              # 路由定义
│   ├── utils/               # 工具函数
│   │   ├── matching-algorithm.ts
│   │   ├── excel-parser.ts
│   │   └── logger.ts
│   ├── config/              # 配置文件
│   │   ├── database.ts
│   │   ├── redis.ts
│   │   └── env.ts
│   └── app.ts
├── tests/                   # 测试文件
├── docs/                    # API文档
├── docker/                  # Docker配置
├── package.json
├── tsconfig.json
└── ecosystem.config.js      # PM2配置
```

---

## 🔧 核心模块设计

### 1. 智能匹配引擎

#### 匹配算法接口

```typescript
interface MatchingEngine {
  /**
   * 执行智能匹配
   * @param wholesaleItems 批发商品数据
   * @param productArchive 商品档案
   * @param config 匹配配置
   */
  match(
    wholesaleItems: WholesaleItem[],
    productArchive: ProductArchive[],
    config: MatchingConfig
  ): Promise<MatchingResult[]>

  /**
   * 计算相似度分数
   */
  calculateSimilarity(
    wholesale: WholesaleItem,
    product: ProductArchive
  ): SimilarityScore

  /**
   * 学习用户选择偏好
   */
  learnFromUserChoice(
    wholesale: WholesaleItem,
    selectedProduct: ProductArchive,
    rejectedProducts: ProductArchive[]
  ): void
}
```

#### 算法实现

```typescript
class SmartMatchingEngine implements MatchingEngine {
  private readonly weights = {
    name: 0.35,
    brand: 0.25,
    keywords: 0.2,
    package: 0.1,
    price: 0.1,
  }

  async match(
    wholesaleItems: WholesaleItem[],
    productArchive: ProductArchive[],
    config: MatchingConfig
  ): Promise<MatchingResult[]> {
    const results: MatchingResult[] = []

    for (const item of wholesaleItems) {
      const candidates = await this.findCandidates(item, productArchive)
      const scoredCandidates = candidates
        .map((candidate) => ({
          product: candidate,
          score: this.calculateSimilarity(item, candidate),
        }))
        .sort((a, b) => b.score.total - a.score.total)
        .slice(0, 5) // 取前5个候选

      results.push({
        wholesaleItem: item,
        candidates: scoredCandidates,
        confidence: this.determineConfidence(
          scoredCandidates[0]?.score.total || 0
        ),
        recommendedAction: this.getRecommendedAction(
          scoredCandidates[0]?.score.total || 0
        ),
      })
    }

    return results
  }

  calculateSimilarity(
    wholesale: WholesaleItem,
    product: ProductArchive
  ): SimilarityScore {
    const nameScore = this.calculateNameSimilarity(wholesale.name, product.name)
    const brandScore = this.calculateBrandSimilarity(
      wholesale.name,
      product.brand
    )
    const keywordScore = this.calculateKeywordSimilarity(
      wholesale.name,
      product.keywords
    )
    const packageScore = this.calculatePackageSimilarity(
      wholesale.name,
      product.specifications
    )
    const priceScore = this.calculatePriceSimilarity(
      wholesale.price,
      product.specifications.price
    )

    const total =
      nameScore * this.weights.name +
      brandScore * this.weights.brand +
      keywordScore * this.weights.keywords +
      packageScore * this.weights.package +
      priceScore * this.weights.price

    return {
      name: nameScore,
      brand: brandScore,
      keywords: keywordScore,
      package: packageScore,
      price: priceScore,
      total: Math.round(total * 100) / 100,
    }
  }
}
```

### 2. 任务队列系统

#### 队列配置

```typescript
import Bull from "bull"
import { redisConfig } from "../config/redis"

// 匹配任务队列
export const matchingQueue = new Bull("matching tasks", {
  redis: redisConfig,
  defaultJobOptions: {
    removeOnComplete: 100,
    removeOnFail: 50,
    attempts: 3,
    backoff: {
      type: "exponential",
      delay: 2000,
    },
  },
})

// 价格更新队列
export const priceUpdateQueue = new Bull("price updates", {
  redis: redisConfig,
})

// 报表生成队列
export const reportQueue = new Bull("report generation", {
  redis: redisConfig,
})
```

#### 任务处理器

```typescript
matchingQueue.process("smart-matching", async (job) => {
  const { taskId, wholesaleData, config } = job.data

  try {
    // 更新任务状态
    await MatchingTask.findByIdAndUpdate(taskId, {
      status: "processing",
      startedAt: new Date(),
    })

    const engine = new SmartMatchingEngine()
    const productArchive = await Product.find({})

    // 执行匹配
    const results = await engine.match(wholesaleData, productArchive, config)

    // 保存结果
    await MatchingRecord.insertMany(
      results.map((result) => ({
        taskId,
        ...result,
      }))
    )

    // 更新任务完成状态
    await MatchingTask.findByIdAndUpdate(taskId, {
      status: "completed",
      completedAt: new Date(),
      totalItems: results.length,
      processedItems: results.length,
    })

    return { success: true, processedCount: results.length }
  } catch (error) {
    await MatchingTask.findByIdAndUpdate(taskId, {
      status: "failed",
      error: error.message,
    })
    throw error
  }
})
```

### 3. 数据模型定义

#### MongoDB Schema

```typescript
// 商品档案模型
const ProductSchema = new Schema(
  {
    name: { type: String, required: true, index: true },
    brand: { type: String, required: true, index: true },
    keywords: [{ type: String, index: true }],
    category: { type: String, index: true },
    specifications: {
      packageType: String,
      size: String,
      price: Number,
    },
    wholesaleName: String,
    wholesalePrice: Number,
    isActive: { type: Boolean, default: true },
    createdAt: { type: Date, default: Date.now },
    updatedAt: { type: Date, default: Date.now },
  },
  {
    timestamps: true,
  }
)

// 添加文本搜索索引
ProductSchema.index({
  name: "text",
  brand: "text",
  keywords: "text",
})

// 匹配任务模型
const MatchingTaskSchema = new Schema(
  {
    filename: { type: String, required: true },
    originalFilename: String,
    fileSize: Number,
    status: {
      type: String,
      enum: ["pending", "processing", "review", "completed", "failed"],
      default: "pending",
    },
    config: {
      threshold: { type: Number, default: 65 },
      autoConfirmThreshold: { type: Number, default: 90 },
      strategies: {
        brandPriority: { type: Boolean, default: true },
        keywordMatching: { type: Boolean, default: true },
        packageTypeRecognition: { type: Boolean, default: true },
        priceValidation: { type: Boolean, default: true },
      },
    },
    progress: {
      totalItems: { type: Number, default: 0 },
      processedItems: { type: Number, default: 0 },
      confirmedItems: { type: Number, default: 0 },
      pendingItems: { type: Number, default: 0 },
    },
    createdBy: { type: Schema.Types.ObjectId, ref: "User", required: true },
    startedAt: Date,
    completedAt: Date,
    error: String,
  },
  {
    timestamps: true,
  }
)

// 匹配记录模型
const MatchingRecordSchema = new Schema(
  {
    taskId: {
      type: Schema.Types.ObjectId,
      ref: "MatchingTask",
      required: true,
    },
    wholesaleName: { type: String, required: true },
    wholesalePrice: { type: Number, required: true },

    candidates: [
      {
        productId: { type: Schema.Types.ObjectId, ref: "Product" },
        score: {
          name: Number,
          brand: Number,
          keywords: Number,
          package: Number,
          price: Number,
          total: Number,
        },
        confidence: {
          type: String,
          enum: ["high", "medium", "low"],
        },
        reason: String,
      },
    ],

    selectedMatch: {
      productId: { type: Schema.Types.ObjectId, ref: "Product" },
      confirmedBy: { type: Schema.Types.ObjectId, ref: "User" },
      confirmedAt: Date,
      note: String,
      confidence: Number,
    },

    status: {
      type: String,
      enum: ["pending", "reviewing", "confirmed", "rejected", "exception"],
      default: "pending",
    },

    priority: {
      type: String,
      enum: ["high", "medium", "low"],
      default: "medium",
    },

    reviewHistory: [
      {
        action: String,
        performer: { type: Schema.Types.ObjectId, ref: "User" },
        timestamp: { type: Date, default: Date.now },
        note: String,
        previousStatus: String,
        newStatus: String,
      },
    ],
  },
  {
    timestamps: true,
  }
)
```

### 4. API 接口设计

#### RESTful API 结构

```typescript
// 匹配任务相关接口
POST   /api/matching/tasks              // 创建匹配任务
GET    /api/matching/tasks              // 获取任务列表
GET    /api/matching/tasks/:id          // 获取任务详情
PUT    /api/matching/tasks/:id          // 更新任务状态
DELETE /api/matching/tasks/:id          // 删除任务

// 匹配记录相关接口
GET    /api/matching/records            // 获取匹配记录列表
GET    /api/matching/records/:id        // 获取记录详情
PUT    /api/matching/records/:id/confirm // 确认匹配
PUT    /api/matching/records/:id/reject  // 拒绝匹配
POST   /api/matching/records/batch      // 批量操作

// 商品档案相关接口
GET    /api/products                    // 获取商品列表
POST   /api/products                    // 创建商品
PUT    /api/products/:id                // 更新商品
DELETE /api/products/:id                // 删除商品
POST   /api/products/import             // 批量导入
GET    /api/products/export             // 导出商品

// 价格管理相关接口
GET    /api/prices/changes              // 获取价格变动记录
POST   /api/prices/update               // 更新价格
GET    /api/prices/analysis             // 价格分析数据
GET    /api/prices/trends               // 价格趋势数据

// 统计报表相关接口
GET    /api/reports/efficiency          // 效率报表
GET    /api/reports/accuracy            // 准确率报表
GET    /api/reports/summary             // 汇总报表
```

#### 接口实现示例

```typescript
// 匹配任务控制器
export class MatchingController {
  async createTask(req: Request, res: Response) {
    try {
      const { file } = req
      const userId = req.user.id

      // 解析Excel文件
      const wholesaleData = await ExcelService.parseWholesaleFile(file.buffer)

      // 创建任务记录
      const task = new MatchingTask({
        filename: file.filename,
        originalFilename: file.originalname,
        fileSize: file.size,
        createdBy: userId,
        progress: {
          totalItems: wholesaleData.length,
        },
      })

      await task.save()

      // 添加到队列
      await matchingQueue.add("smart-matching", {
        taskId: task._id,
        wholesaleData,
        config: req.body.config || {},
      })

      res.status(201).json({
        success: true,
        data: task,
        message: "匹配任务创建成功",
      })
    } catch (error) {
      res.status(500).json({
        success: false,
        message: error.message,
      })
    }
  }

  async getTaskProgress(req: Request, res: Response) {
    try {
      const { id } = req.params
      const task = await MatchingTask.findById(id).populate(
        "createdBy",
        "name email"
      )

      if (!task) {
        return res.status(404).json({
          success: false,
          message: "任务不存在",
        })
      }

      // 获取匹配记录统计
      const recordStats = await MatchingRecord.aggregate([
        { $match: { taskId: new ObjectId(id) } },
        {
          $group: {
            _id: "$status",
            count: { $sum: 1 },
          },
        },
      ])

      res.json({
        success: true,
        data: {
          task,
          statistics: recordStats,
        },
      })
    } catch (error) {
      res.status(500).json({
        success: false,
        message: error.message,
      })
    }
  }
}
```

---

## 🔒 安全架构

### 1. 认证授权

```typescript
// JWT令牌配置
const jwtConfig = {
  secret: process.env.JWT_SECRET,
  expiresIn: "24h",
  refreshExpiresIn: "7d",
}

// 权限中间件
export const authorize = (permissions: string[]) => {
  return async (req: Request, res: Response, next: NextFunction) => {
    try {
      const user = req.user
      const hasPermission = permissions.some((permission) =>
        user.permissions.includes(permission)
      )

      if (!hasPermission) {
        return res.status(403).json({
          success: false,
          message: "权限不足",
        })
      }

      next()
    } catch (error) {
      res.status(401).json({
        success: false,
        message: "认证失败",
      })
    }
  }
}
```

### 2. 数据加密

- 密码使用 bcrypt 哈希加密
- 敏感数据传输使用 HTTPS
- 数据库连接使用 TLS 加密
- API 密钥加密存储

### 3. 输入验证

```typescript
// 请求数据验证中间件
export const validateRequest = (schema: Joi.Schema) => {
  return (req: Request, res: Response, next: NextFunction) => {
    const { error } = schema.validate(req.body)

    if (error) {
      return res.status(400).json({
        success: false,
        message: "请求数据格式错误",
        details: error.details,
      })
    }

    next()
  }
}

// 文件上传验证
export const validateFileUpload = (
  req: Request,
  res: Response,
  next: NextFunction
) => {
  const { file } = req

  if (!file) {
    return res.status(400).json({
      success: false,
      message: "请上传文件",
    })
  }

  // 检查文件类型
  const allowedTypes = [
    "application/vnd.ms-excel",
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
  ]

  if (!allowedTypes.includes(file.mimetype)) {
    return res.status(400).json({
      success: false,
      message: "文件类型不支持，请上传Excel文件",
    })
  }

  // 检查文件大小 (10MB)
  if (file.size > 10 * 1024 * 1024) {
    return res.status(400).json({
      success: false,
      message: "文件大小不能超过10MB",
    })
  }

  next()
}
```

---

## 📊 性能优化

### 1. 数据库优化

```typescript
// 数据库连接池配置
const mongoConfig = {
  maxPoolSize: 10,
  minPoolSize: 2,
  maxIdleTimeMS: 30000,
  serverSelectionTimeoutMS: 5000,
  socketTimeoutMS: 45000,
}

// 查询优化
class ProductService {
  // 使用索引优化查询
  async searchProducts(query: string, filters: any) {
    const aggregation = [
      {
        $match: {
          $and: [
            { $text: { $search: query } },
            filters.brand ? { brand: filters.brand } : {},
            filters.category ? { category: filters.category } : {},
          ],
        },
      },
      {
        $addFields: {
          score: { $meta: "textScore" },
        },
      },
      {
        $sort: { score: { $meta: "textScore" } },
      },
      {
        $limit: 50,
      },
    ]

    return Product.aggregate(aggregation)
  }

  // 分页查询
  async getProductsPaginated(page: number, limit: number) {
    const skip = (page - 1) * limit

    const [products, total] = await Promise.all([
      Product.find({}).skip(skip).limit(limit).lean(), // 使用lean()提高性能
      Product.countDocuments({}),
    ])

    return {
      products,
      pagination: {
        page,
        limit,
        total,
        pages: Math.ceil(total / limit),
      },
    }
  }
}
```

### 2. 缓存策略

```typescript
// Redis缓存配置
class CacheService {
  private redis: Redis

  constructor() {
    this.redis = new Redis({
      host: process.env.REDIS_HOST,
      port: parseInt(process.env.REDIS_PORT),
      password: process.env.REDIS_PASSWORD,
      retryDelayOnFailover: 100,
      enableReadyCheck: false,
      maxRetriesPerRequest: null,
    })
  }

  // 缓存商品数据
  async cacheProducts(products: Product[]) {
    const pipeline = this.redis.pipeline()

    products.forEach((product) => {
      pipeline.setex(
        `product:${product._id}`,
        3600, // 1小时过期
        JSON.stringify(product)
      )
    })

    await pipeline.exec()
  }

  // 缓存匹配结果
  async cacheMatchingResults(taskId: string, results: any[]) {
    await this.redis.setex(
      `matching:${taskId}`,
      1800, // 30分钟过期
      JSON.stringify(results)
    )
  }

  // 缓存统计数据
  async cacheStatistics(key: string, data: any, ttl: number = 300) {
    await this.redis.setex(`stats:${key}`, ttl, JSON.stringify(data))
  }
}
```

### 3. 前端性能优化

```typescript
// Next.js 应用组件配置
import { NextUIProvider } from "@nextui-org/react"
import { ThemeProvider as NextThemesProvider } from "next-themes"

// 虚拟滚动组件 (基于 NextUI Table)
import {
  Table,
  TableHeader,
  TableColumn,
  TableBody,
  TableRow,
  TableCell,
} from "@nextui-org/react"
import { useMemo } from "react"

const VirtualizedTable: React.FC<{
  items: any[]
  columns: any[]
  height?: number
}> = ({ items, columns, height = 400 }) => {
  const rows = useMemo(() => {
    return items.map((item, index) => ({
      key: index,
      ...item,
    }))
  }, [items])

  return (
    <Table
      aria-label='数据表格'
      selectionMode='multiple'
      isStriped
      classNames={{
        wrapper: `max-h-[${height}px]`,
      }}
    >
      <TableHeader columns={columns}>
        {(column) => (
          <TableColumn
            key={column.key}
            align={column.align}
            allowsSorting={column.sortable}
          >
            {column.label}
          </TableColumn>
        )}
      </TableHeader>
      <TableBody items={rows}>
        {(item) => (
          <TableRow key={item.key}>
            {(columnKey) => <TableCell>{item[columnKey]}</TableCell>}
          </TableRow>
        )}
      </TableBody>
    </Table>
  )
}

// 无限滚动 Hook (结合 SWR)
import useSWRInfinite from "swr/infinite"

const useInfiniteData = <T>(endpoint: string, pageSize: number = 20) => {
  const { data, error, size, setSize, isValidating, isLoading } =
    useSWRInfinite<{ data: T[]; hasMore: boolean }>(
      (index) => `${endpoint}?page=${index + 1}&limit=${pageSize}`,
      fetcher
    )

  const items = data ? data.flatMap((page) => page.data) : []
  const hasMore = data && data[data.length - 1]?.hasMore

  return {
    items,
    error,
    isLoading,
    isValidating,
    loadMore: () => setSize(size + 1),
    hasMore,
  }
}

// 状态管理 (Zustand)
import { create } from "zustand"
import { devtools, persist } from "zustand/middleware"

interface AppState {
  theme: "light" | "dark"
  user: User | null
  setTheme: (theme: "light" | "dark") => void
  setUser: (user: User | null) => void
}

export const useAppStore = create<AppState>()(
  devtools(
    persist(
      (set) => ({
        theme: "light",
        user: null,
        setTheme: (theme) => set({ theme }),
        setUser: (user) => set({ user }),
      }),
      {
        name: "app-storage",
        partialize: (state) => ({ theme: state.theme }),
      }
    )
  )
)
```

---

## 🚀 部署架构

### 服务器部署配置

#### 系统要求

- **操作系统**: CentOS 7+ / Ubuntu 18.04+ / Windows Server 2019+
- **Node.js**: 18.x LTS
- **内存**: 最低 4GB，推荐 8GB+
- **存储**: 最低 50GB，推荐 100GB+
- **网络**: 稳定的网络连接

#### 环境准备

```bash
# 1. 安装 Node.js 18 (使用国内镜像)
curl -fsSL https://rpm.nodesource.com/setup_18.x | sudo bash -
sudo yum install -y nodejs

# 或者使用 nvm (推荐)
curl -o- https://gitee.com/mirrors/nvm/raw/master/install.sh | bash
nvm install 18
nvm use 18

# 2. 配置 npm 国内镜像
npm config set registry https://registry.npmmirror.com

# 3. 安装 pnpm (可选)
npm install -g pnpm
pnpm config set registry https://registry.npmmirror.com

# 4. 安装 PM2
npm install -g pm2

# 5. 安装 MongoDB (使用官方源或阿里云镜像)
# CentOS/RHEL
sudo yum install -y mongodb-org

# Ubuntu
sudo apt-get install -y mongodb

# 6. 安装 Redis
sudo yum install -y redis
# 或
sudo apt-get install -y redis-server

# 7. 安装 Nginx
sudo yum install -y nginx
# 或
sudo apt-get install -y nginx
```

### PM2 部署配置

```javascript
// ecosystem.config.js - 后端配置
module.exports = {
  apps: [
    {
      name: "smart-match-api",
      script: "dist/app.js",
      cwd: "/path/to/smart-match-api",
      instances: "max", // 或指定实例数
      exec_mode: "cluster",
      env: {
        NODE_ENV: "development",
        PORT: 3001,
      },
      env_production: {
        NODE_ENV: "production",
        PORT: 3001,
        MONGODB_URI: "mongodb://localhost:27017/smartmatch",
        REDIS_URL: "redis://localhost:6379",
        JWT_SECRET: "your-jwt-secret",
      },
      error_file: "./logs/err.log",
      out_file: "./logs/out.log",
      log_file: "./logs/combined.log",
      time: true,
      autorestart: true,
      watch: false,
      max_memory_restart: "1G",
      env_file: ".env",
    },
  ],
}

// ecosystem.config.js - 前端配置
module.exports = {
  apps: [
    {
      name: "smart-match-web",
      script: "server.js", // Next.js standalone 模式
      cwd: "/path/to/smart-match-web",
      instances: 2,
      exec_mode: "cluster",
      env: {
        NODE_ENV: "development",
        PORT: 3000,
      },
      env_production: {
        NODE_ENV: "production",
        PORT: 3000,
        NEXT_PUBLIC_API_URL: "http://localhost:3001",
      },
      error_file: "./logs/err.log",
      out_file: "./logs/out.log",
      log_file: "./logs/combined.log",
      time: true,
      autorestart: true,
      watch: false,
      max_memory_restart: "512M",
    },
  ],
}
```

### Nginx 配置

```nginx
# nginx.conf
upstream smart_match_web {
    server 127.0.0.1:3000;
}

upstream smart_match_api {
    server 127.0.0.1:3001;
}

server {
    listen 80;
    server_name your-domain.com;

    # 前端静态文件
    location / {
        proxy_pass http://smart_match_web;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;
    }

    # API 代理
    location /api/ {
        proxy_pass http://smart_match_api;
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection 'upgrade';
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_cache_bypass $http_upgrade;

        # 文件上传大小限制
        client_max_body_size 10M;
    }

    # 静态资源缓存
    location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg)$ {
        proxy_pass http://smart_match_web;
        expires 1y;
        add_header Cache-Control "public, immutable";
    }
}

# HTTPS 配置 (可选)
server {
    listen 443 ssl http2;
    server_name your-domain.com;

    ssl_certificate /path/to/your/cert.pem;
    ssl_certificate_key /path/to/your/key.pem;

    # SSL 配置
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384;
    ssl_prefer_server_ciphers off;

    # 其他配置同上...
}
```

### 部署脚本

```bash
#!/bin/bash
# deploy.sh - 自动化部署脚本

set -e

echo "🚀 开始部署智能商品匹配系统..."

# 配置变量
PROJECT_DIR="/opt/smart-match-system"
API_DIR="$PROJECT_DIR/api"
WEB_DIR="$PROJECT_DIR/web"
BACKUP_DIR="/opt/backups/$(date +%Y%m%d_%H%M%S)"

# 创建备份
echo "📦 创建备份..."
mkdir -p $BACKUP_DIR
if [ -d "$PROJECT_DIR" ]; then
    cp -r $PROJECT_DIR $BACKUP_DIR/
fi

# 拉取最新代码
echo "📥 拉取最新代码..."
cd $PROJECT_DIR
git pull origin main

# 部署后端
echo "🔧 部署后端..."
cd $API_DIR
npm install --production
npm run build

# 重启后端服务
pm2 restart smart-match-api || pm2 start ecosystem.config.js --env production

# 部署前端
echo "🎨 部署前端..."
cd $WEB_DIR
npm install
npm run build

# 重启前端服务
pm2 restart smart-match-web || pm2 start ecosystem.config.js --env production

# 重新加载 Nginx
echo "🔄 重新加载 Nginx..."
sudo nginx -t && sudo nginx -s reload

echo "✅ 部署完成！"
echo "📊 检查服务状态..."
pm2 status

# 健康检查
echo "🔍 健康检查..."
sleep 5
curl -f http://localhost:3001/health || echo "❌ 后端健康检查失败"
curl -f http://localhost:3000 || echo "❌ 前端健康检查失败"

echo "🎉 部署成功！"
```

### 自动化部署配置

```yaml
# .github/workflows/deploy.yml (如果使用 GitHub Actions)
name: Deploy to Production

on:
  push:
    branches: [main]

jobs:
  deploy:
    runs-on: ubuntu-latest
    if: github.ref == 'refs/heads/main'

    steps:
      - name: Deploy to server
        uses: appleboy/ssh-action@v0.1.5
        with:
          host: ${{ secrets.HOST }}
          username: ${{ secrets.USERNAME }}
          key: ${{ secrets.SSH_KEY }}
          script: |
            cd /opt/smart-match-system
            chmod +x deploy.sh
            ./deploy.sh
```

---

## 📈 监控与日志

### PM2 监控

```javascript
// PM2 监控配置
// 在 ecosystem.config.js 中添加监控配置
module.exports = {
  apps: [
    {
      name: "smart-match-api",
      // ... 其他配置
      monitoring: true,
      pmx: true,
    },
  ],

  // 部署配置
  deploy: {
    production: {
      user: "deploy",
      host: ["your-server.com"],
      ref: "origin/main",
      repo: "git@github.com:username/smart-match-system.git",
      path: "/opt/smart-match-system",
      "post-deploy": "npm install && npm run build && pm2 reload ecosystem.config.js --env production",
    },
  },
}

// 监控命令
pm2 monit              // 实时监控
pm2 status             // 查看状态
pm2 logs               // 查看日志
pm2 logs --lines 200   // 查看最近200行日志
```

### 自定义监控

```typescript
// 自定义监控中间件
import { Request, Response, NextFunction } from "express"
import { logger } from "../utils/logger"

interface MetricsData {
  requests: number
  errors: number
  responseTime: number[]
  activeConnections: number
}

class SimpleMonitor {
  private metrics: MetricsData = {
    requests: 0,
    errors: 0,
    responseTime: [],
    activeConnections: 0,
  }

  // 监控中间件
  middleware() {
    return (req: Request, res: Response, next: NextFunction) => {
      const start = Date.now()
      this.metrics.requests++
      this.metrics.activeConnections++

      res.on("finish", () => {
        const duration = Date.now() - start
        this.metrics.responseTime.push(duration)
        this.metrics.activeConnections--

        if (res.statusCode >= 400) {
          this.metrics.errors++
        }

        // 记录慢请求
        if (duration > 1000) {
          logger.warn(`Slow request: ${req.method} ${req.path} - ${duration}ms`)
        }
      })

      next()
    }
  }

  // 获取监控数据
  getMetrics() {
    const avgResponseTime =
      this.metrics.responseTime.length > 0
        ? this.metrics.responseTime.reduce((a, b) => a + b) /
          this.metrics.responseTime.length
        : 0

    return {
      ...this.metrics,
      avgResponseTime: Math.round(avgResponseTime),
      errorRate: (this.metrics.errors / this.metrics.requests) * 100,
    }
  }

  // 重置指标
  reset() {
    this.metrics = {
      requests: 0,
      errors: 0,
      responseTime: [],
      activeConnections: 0,
    }
  }
}

export const monitor = new SimpleMonitor()

// 监控路由
app.get("/api/monitor/metrics", (req, res) => {
  res.json(monitor.getMetrics())
})
```

### 日志配置

```typescript
import winston from "winston"
import DailyRotateFile from "winston-daily-rotate-file"

// 日志轮转配置
const createRotatingTransport = (filename: string, level?: string) => {
  return new DailyRotateFile({
    filename: `logs/${filename}-%DATE%.log`,
    datePattern: "YYYY-MM-DD",
    zippedArchive: true,
    maxSize: "20m",
    maxFiles: "14d", // 保留14天
    level,
  })
}

const logger = winston.createLogger({
  level: process.env.LOG_LEVEL || "info",
  format: winston.format.combine(
    winston.format.timestamp({
      format: "YYYY-MM-DD HH:mm:ss",
    }),
    winston.format.errors({ stack: true }),
    winston.format.printf(({ timestamp, level, message, stack, ...meta }) => {
      let log = `${timestamp} [${level.toUpperCase()}]: ${message}`
      if (stack) {
        log += `\n${stack}`
      }
      if (Object.keys(meta).length > 0) {
        log += `\n${JSON.stringify(meta, null, 2)}`
      }
      return log
    })
  ),
  defaultMeta: {
    service: "smart-match-api",
    pid: process.pid,
  },
  transports: [
    // 错误日志
    createRotatingTransport("error", "error"),

    // 组合日志
    createRotatingTransport("combined"),

    // 控制台输出
    new winston.transports.Console({
      format: winston.format.combine(
        winston.format.colorize(),
        winston.format.simple()
      ),
    }),
  ],
})

// 生产环境不输出到控制台
if (process.env.NODE_ENV === "production") {
  logger.remove(logger.transports[2]) // 移除控制台输出
}

export { logger }
```

### 系统监控脚本

```bash
#!/bin/bash
# monitor.sh - 系统监控脚本

LOG_FILE="/var/log/smart-match-monitor.log"

# 记录日志函数
log() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') - $1" >> $LOG_FILE
}

# 检查服务状态
check_services() {
    log "开始检查服务状态..."

    # 检查 PM2 进程
    if ! pm2 status | grep -q "online"; then
        log "ERROR: PM2 服务异常"
        # 重启服务
        pm2 restart all
        log "INFO: 已尝试重启 PM2 服务"
    fi

    # 检查 MongoDB
    if ! pgrep mongod > /dev/null; then
        log "ERROR: MongoDB 未运行"
        sudo systemctl start mongod
        log "INFO: 已启动 MongoDB"
    fi

    # 检查 Redis
    if ! pgrep redis-server > /dev/null; then
        log "ERROR: Redis 未运行"
        sudo systemctl start redis
        log "INFO: 已启动 Redis"
    fi

    # 检查 Nginx
    if ! pgrep nginx > /dev/null; then
        log "ERROR: Nginx 未运行"
        sudo systemctl start nginx
        log "INFO: 已启动 Nginx"
    fi

    log "服务状态检查完成"
}

# 检查磁盘空间
check_disk_space() {
    DISK_USAGE=$(df / | awk 'NR==2{print $5}' | cut -d'%' -f1)
    if [ $DISK_USAGE -gt 80 ]; then
        log "WARNING: 磁盘使用率过高: ${DISK_USAGE}%"

        # 清理日志文件 (保留最近7天)
        find /opt/smart-match-system/*/logs -name "*.log" -mtime +7 -delete
        log "INFO: 已清理过期日志文件"
    fi
}

# 检查内存使用
check_memory() {
    MEMORY_USAGE=$(free | grep Mem | awk '{printf "%.2f", $3/$2 * 100.0}')
    if (( $(echo "$MEMORY_USAGE > 90" | bc -l) )); then
        log "WARNING: 内存使用率过高: ${MEMORY_USAGE}%"
    fi
}

# 健康检查
health_check() {
    # 检查 API 健康状态
    if ! curl -f -s http://localhost:3001/health > /dev/null; then
        log "ERROR: API 健康检查失败"
        pm2 restart smart-match-api
        log "INFO: 已重启 API 服务"
    fi

    # 检查前端状态
    if ! curl -f -s http://localhost:3000 > /dev/null; then
        log "ERROR: 前端健康检查失败"
        pm2 restart smart-match-web
        log "INFO: 已重启前端服务"
    fi
}

# 主函数
main() {
    log "============ 开始监控检查 ============"
    check_services
    check_disk_space
    check_memory
    health_check
    log "============ 监控检查完成 ============"
}

# 运行监控
main

# 添加到 crontab 中每5分钟执行一次
# */5 * * * * /opt/smart-match-system/monitor.sh
```

---

## ⚙️ 配置文件示例

### Next.js 配置

```javascript
// next.config.js
/** @type {import('next').NextConfig} */
const nextConfig = {
  experimental: {
    appDir: true,
    turbo: {
      rules: {
        "*.svg": {
          loaders: ["@svgr/webpack"],
          as: "*.js",
        },
      },
    },
  },
  images: {
    domains: ["localhost", "your-cdn-domain.com"],
  },
  output: "standalone",
  async rewrites() {
    return [
      {
        source: "/api/:path*",
        destination: `${process.env.NEXT_PUBLIC_API_URL}/api/:path*`,
      },
    ]
  },
}

module.exports = nextConfig
```

### NextUI + Tailwind 配置

```typescript
// tailwind.config.ts
import { nextui } from "@nextui-org/react"

/** @type {import('tailwindcss').Config} */
module.exports = {
  content: [
    "./src/pages/**/*.{js,ts,jsx,tsx,mdx}",
    "./src/components/**/*.{js,ts,jsx,tsx,mdx}",
    "./src/app/**/*.{js,ts,jsx,tsx,mdx}",
    "./node_modules/@nextui-org/theme/dist/**/*.{js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {
      fontFamily: {
        sans: ["Inter", "PingFang SC", "Microsoft YaHei", "sans-serif"],
      },
    },
  },
  darkMode: "class",
  plugins: [
    nextui({
      themes: {
        light: {
          colors: {
            primary: {
              50: "#eff6ff",
              100: "#dbeafe",
              500: "#3b82f6",
              600: "#2563eb",
              900: "#1e3a8a",
            },
          },
        },
        dark: {
          colors: {
            primary: {
              50: "#1e293b",
              100: "#334155",
              500: "#64748b",
              600: "#475569",
              900: "#0f172a",
            },
          },
        },
      },
    }),
  ],
}
```

### 应用程序根布局

```typescript
// src/app/layout.tsx
import { Providers } from "./providers"
import { Inter } from "next/font/google"
import "./globals.css"

const inter = Inter({ subsets: ["latin"] })

export const metadata = {
  title: "智能商品匹配系统",
  description: "基于AI的商品匹配与价格管理系统",
}

export default function RootLayout({
  children,
}: {
  children: React.ReactNode
}) {
  return (
    <html lang='zh-CN' suppressHydrationWarning>
      <body className={inter.className}>
        <Providers>{children}</Providers>
      </body>
    </html>
  )
}
```

### 提供者配置

```typescript
// src/app/providers.tsx
"use client"

import { NextUIProvider } from "@nextui-org/react"
import { ThemeProvider as NextThemesProvider } from "next-themes"
import { SWRConfig } from "swr"

export function Providers({ children }: { children: React.ReactNode }) {
  return (
    <NextUIProvider>
      <NextThemesProvider
        attribute='class'
        defaultTheme='light'
        themes={["light", "dark"]}
      >
        <SWRConfig
          value={{
            fetcher: (url: string) => fetch(url).then((res) => res.json()),
            errorRetryCount: 3,
            errorRetryInterval: 5000,
          }}
        >
          {children}
        </SWRConfig>
      </NextThemesProvider>
    </NextUIProvider>
  )
}
```

### API 路由示例

```typescript
// src/app/api/matching/route.ts
import { NextRequest, NextResponse } from "next/server"
import { headers } from "next/headers"

export async function POST(request: NextRequest) {
  try {
    const headersList = headers()
    const authorization = headersList.get("authorization")

    if (!authorization) {
      return NextResponse.json(
        { success: false, message: "未授权访问" },
        { status: 401 }
      )
    }

    const body = await request.json()

    // 调用后端API
    const response = await fetch(`${process.env.API_BASE_URL}/api/matching`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: authorization,
      },
      body: JSON.stringify(body),
    })

    const data = await response.json()

    return NextResponse.json(data, { status: response.status })
  } catch (error) {
    return NextResponse.json(
      { success: false, message: "服务器错误" },
      { status: 500 }
    )
  }
}
```

---

## 🎨 UI 组件设计

### 主题化组件示例

```typescript
// src/components/ui/matching-card.tsx
"use client"

import {
  Card,
  CardBody,
  CardHeader,
  Progress,
  Chip,
  Button,
  Badge,
} from "@nextui-org/react"
import { cn } from "@/lib/utils"

interface MatchingCardProps {
  item: {
    name: string
    confidence: number
    status: "pending" | "processing" | "completed"
    candidates: number
  }
  className?: string
}

export const MatchingCard: React.FC<MatchingCardProps> = ({
  item,
  className,
}) => {
  const getStatusColor = (status: string) => {
    switch (status) {
      case "completed":
        return "success"
      case "processing":
        return "warning"
      default:
        return "default"
    }
  }

  const getConfidenceColor = (confidence: number) => {
    if (confidence >= 90) return "success"
    if (confidence >= 70) return "warning"
    return "danger"
  }

  return (
    <Card className={cn("w-full", className)}>
      <CardHeader className='flex gap-3'>
        <div className='flex flex-col flex-1'>
          <p className='text-md font-semibold'>{item.name}</p>
          <p className='text-small text-default-500'>
            {item.candidates} 个候选匹配
          </p>
        </div>
        <Badge
          content={`${item.confidence}%`}
          color={getConfidenceColor(item.confidence)}
          variant='flat'
        >
          <Chip color={getStatusColor(item.status)} variant='flat' size='sm'>
            {item.status}
          </Chip>
        </Badge>
      </CardHeader>
      <CardBody className='pt-0'>
        <Progress
          size='sm'
          value={item.confidence}
          color={getConfidenceColor(item.confidence)}
          showValueLabel
        />
        <div className='flex gap-2 mt-4'>
          <Button size='sm' variant='flat'>
            查看详情
          </Button>
          <Button size='sm' color='primary'>
            确认匹配
          </Button>
        </div>
      </CardBody>
    </Card>
  )
}
```

---

## 📊 数据可视化

### 基于 Recharts 的图表组件

```typescript
// src/components/charts/matching-trend.tsx
"use client"

import {
  LineChart,
  Line,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  ResponsiveContainer,
} from "recharts"
import { Card, CardBody, CardHeader } from "@nextui-org/react"

interface TrendData {
  date: string
  accuracy: number
  efficiency: number
  volume: number
}

interface MatchingTrendProps {
  data: TrendData[]
  title?: string
}

export const MatchingTrend: React.FC<MatchingTrendProps> = ({
  data,
  title = "匹配趋势分析",
}) => {
  return (
    <Card className='w-full'>
      <CardHeader>
        <h3 className='text-lg font-semibold'>{title}</h3>
      </CardHeader>
      <CardBody>
        <ResponsiveContainer width='100%' height={400}>
          <LineChart data={data}>
            <CartesianGrid strokeDasharray='3 3' />
            <XAxis dataKey='date' tick={{ fontSize: 12 }} />
            <YAxis tick={{ fontSize: 12 }} />
            <Tooltip
              contentStyle={{
                backgroundColor: "rgba(255, 255, 255, 0.95)",
                border: "1px solid #e2e8f0",
                borderRadius: "8px",
              }}
            />
            <Line
              type='monotone'
              dataKey='accuracy'
              stroke='#10b981'
              strokeWidth={2}
              name='准确率 (%)'
            />
            <Line
              type='monotone'
              dataKey='efficiency'
              stroke='#3b82f6'
              strokeWidth={2}
              name='效率 (%)'
            />
          </LineChart>
        </ResponsiveContainer>
      </CardBody>
    </Card>
  )
}
```

---

这个更新后的技术架构文档采用了现代化的技术栈：

- **Node.js 18**: 稳定的 LTS 版本，性能优异
- **Next.js 14**: 最新的全栈 React 框架，支持 App Router
- **NextUI**: 现代化的 UI 组件库，基于 React Aria 和 Tailwind CSS
- **Zustand + SWR**: 轻量级状态管理和数据获取
- **Tailwind CSS**: 原子化 CSS 框架

架构设计注重可扩展性、高性能和高可用性，能够支撑智能匹配系统的业务需求。
